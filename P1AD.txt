Proyecto 1:

ANALISIS Y DISEÑO:

Realizaremos un diseño orientado a objetos.
Para nuestro nuestro servidor necesitamos los objetos: Chat, Server, ServerProcessor y Room los cuales manejar'an todo lo relacionado con el servidor.
Server se encargar'a de recibir y manejar conexiones, ya sea acept'andolas o rechazandolas, de manera concurrente. Si una conexi'on es aceptada se delegar'a a un ServerProcessor y se seguir'an aceptando m'as conexiones, en cambio si la conexion es rechaza simplemente Server la ignorar'a. Server guardar'a el estado de los usuarios conectados y de las salas creadas. Para que el cliente mantenga la conexi'on con el cliente se le solicitar'a identificarse con un nombre de usuario que no haya sido utilizado.


ServerProcessor recibir'a las conexiones aceptadas por Server y ser'a el encargado de enviar y recibir mensajes los cuales ser'an procesados a trav'es de Server.
Room tendra el total de los usuarios que estan en la sala, podr'a dar a conocer qui`enes son los usuarios dentro de la sala.

Del lado del cliente utilizaremos los objetos: Client, ClientProcessor.
Client ser'a el encargado de enviar la solicitud de conexi'on al servidor y abrir el canal de comunicaci'on a trav'es de un Socket.
ClientProcessor una vez establecida la conexi'on con Server procesar'a los mensajes recibidos y adem'as enviar'a nuevos mensajes.

Para el manejo de mensajes tendremos distintos tipos de mensajes dependiendo de lo que se este enviando o recibiendo.


****NUEVO


Realizaremos un diseño orientado a objetos.
Necesitaremos los siguientes objetos: Server, ProcessorServer, ProcessorClient, Room y los diferentes tipos de mensajes que tenemos en el protocolo.
Server se encargar'a de recibir conexiones de manera concurrente. Si una conexi'on es aceptada se crear'a un ProcessorServer el cual se ocupar'a de recibir y enviar mensajes al cliente. La forma en que lo har'a ser'a a trav'es de un ciclo de lectura donde tomar'a el mensaje enviado por el cliente, lo decodificar'a y a traves de un MessageVerifier verificar'a que el mensaje tenga la estructura de un mensaje v'alido, si este es el caso entonces se proceder'a realizando la acci'on determinada en el mensaje y ProcessorServer seguir'a en espera de nuevos mensajes, en otro caso Server desconectar'a al cliente.
Lo primero que debe realizar el usuario es identificarse a trav'es de un nombre de usuario. Una vez identificado el servidor lo guardar'a en un diccionario con todos los usuarios identificados con su correspondiente conexi'on. En caso de que el cliente envie algun mensaje invalido el servidor simplemente lo desconectar'a y lo eliminara del diccionario de usuarios identificados
MessageVerifier s'lo se encargara de tomar mensajes recibidor por ProcessorServer y compararlos con los diferentes tipos de mensajes validos.
El usuario tendra un identificador.


**** NUEVO
Realizaremos un diseño orientado a objetos.
Necesitaremos los siguientes objetos: Server, ServerProcessor, Client, ClientProcessor, Room y los diferentes tipos de mensajes que tenemeos en el protocolo.
Server se encargar'a de todo lo relacionado con el servidor, todo el tiempo estar'a en espera de conexiones. Si una conexion es aceptada, esta se delegar'ra a un ServerProcessor y se seguiran aceptando nuevas conexiones. Server tendra una coleccion de todos los usuarios identificados con su respectiva conexion de forma que si algun usuario manda un mensaje, dependiendo del tipo, se notifcar'a con un mensaje a cada usuario de que tal mensaje ha sido enviado.

ServerProcessor tendra la conexion establecida con el cliente y ser'a el intermediario entre la comunicaci'on del cliente con el servidor, se encargar'a de leer todos los mensajes enviados por el cliente, procesando y enviando las peticiones hechas por el cliente hacia el servidor as'i como de enviar los mensajes del servidor hacia el cliente. 


***VERSION MAS ACTUALIZADA;

Realizaremos un diseño orientado a objetos. Utilizaremos el patron de diseño Modelo-Vista-Controlador.
Comenzaremos con la parte del servidor. Necesitaremos los siguientes objetos: Server, ServerProcessor y Room.

La clase Server representara a nuestro servidor; la misma se encargara de todo lo relacionado al manejo de cuartos, ademas de estar todo el tiempo en espera de nuevas conexiones mientras nuestro programa se este ejecutando. Una vez que alguna conexion sea aceptada por Server, esta sera delegada a una instancia de la clase ServerProcessor, la cual se encargara de todo lo relacionado con la lectura y escritura de mensajes del cliente al servidor y del servidor hacia el cliente respectivamente. Cuando ServerProcessor reciba algun mensaje valido, dentro del protocolo de comunicacion establecido, este realizara la peticion recibida al servidor el cual, dependiendo de lo que se este solicitando el cliente, respondera o bien con un error o con la informacion solicitada. Siempre que el servidor responda con un error significa que la peticion recibida no puede ser realizada. Si el mensaje recibido no es valido entonces ServerProcessor responde con un mensaje de tipo error y se desconecta al cliente. Server servira como el puente de comunicacion entre ServerProcessor y Room con el fin de disminuir el acoplamiento entre clases. Esto implica que algunos metodos en Server seran solo para retornar los valores que regresen algunos metodos en la clase Room.

ServerProcessor tendra como propiedades la conexion del cliente establecida con el servidor, una referencia al servidor, el nombre de usuario -que por defecto al inicio sera la cadena vacia- , el estatus del usuario -que por defecto al inicio sera 'ACTIVE'-, una coleccion con los nombres de los cuartos a los que el usuario pertenece y ademas guardara el estado en una variable booleana de si el usuario ya se ha identificado con el servidor. Dependiendo del tipo de mensaje recibido, que se traduce en la peticion recibida de parte del cliente, ServerProcessor procedera de forma distinta, siempre respondiendo al cliente con algun mensaje, ya sea de error, advertencia o exito.

Para la parte de mensajes tendremos una clase Message, en la cual tendremos todos los tipos de mensajes que vamos a utilizar dado el protocolo. Cada mensaje tendra un metodo con el cual ServerProcessor podra obtener el formato JSON valido, que posteriormente sera enviado hacia el cliente. Esta clase sera utilizada tanto por el servidor como por el cliente.

La clase Room tendra dos colecciones; una con los nombres de los usuarios dentro de la sala y otra de los usuarios invitados que potencialmente podran unirse a la sala. Solo usuarios invitados podran unirse a la sala y una vez que un usuario se una a la sala sera eliminado de los usuarios invitados para formar parte de los miembros de la sala.
El comportamiento en Room se limita a solamente agregar y eliminar usuarios, verificar si un usuario en especifico pertenece a la sala, regresar la lista de usuarios en la sala, remover usuarios de la lista de invitados y decirnos si la sala esta vacia o no. 

Por parte del cliente tendremos una clase Client que se encargara de establecer la comunicacion con el servidor a traves de un enchufe y una clase ClientProcessor que sera analoga a ServerProcessor, manejando todo lo relacionado con lectura y escritura de mensajes. 

Al usuario se le solicitara la direccion IP y el puerto por el cual deseamos establecer una conexion con el servidor. Una vez establecida la conexion podra comenzar a escribir mensajes, crear cuartos y todas las funcionalidades que ofrece el servidor. Los datos ingresados por el usuario seran procesados por ClientProcessor de forma que, dependiendo del caso, creara un Message el cual sera enviado hacia el servidor.

	     
